\documentclass{article}
\usepackage[utf8]{inputenc}

\usepackage[utf8]{inputenc}
\usepackage[parfill]{parskip}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{float}
\usepackage{enumitem}
\usepackage{listingsutf8}
\usepackage{fullpage}
\usepackage{fancyheadings}
\usepackage[absolute]{textpos}
\usepackage[english]{babel}


\begin{document}
\begin{titlepage}
\begin{textblock*}{5cm}(9mm,9mm)
\includegraphics[scale=0.5]{ULB.jpg}
\end{textblock*}
\author{CHRETIEN Marcus, O'CUILLEANAIN Thomas}
\date{\today}
\title{
    \begin{minipage}\linewidth
        \centering
        Project Report
        \vskip10pt
        \large\textbf{Chatroom}
    \end{minipage}
}
\maketitle
\centering
\begin{figure}[H]
  \centering
	\includegraphics[scale=0.4]{SVT.png}
  \label{fig:logo}
\end{figure}
\end{titlepage}

\tableofcontents
\newpage

\section{Introduction}

The goal of this project is to create a basic chatroom capable of sending timestamped and signed messages over a network. This was done by implementing a basic client, capable of connecting and thus sending said messages to a server, and  a multi-client server which forwards the messages it receives to all clients connected to it.

\section{Choices of implementation}

\subsection{Client}

\subsubsection{Sending and receiving messages}
Once we initialised the connection between the client and the server, we decided to manage the exchange of messages by creating two threads client side, one to manage all reception of messages and the other to manage all sending of messages. \par
This is because the the system calls $read$ and $write$ are blocking calls. This means that without using a thread, a user would be unable to send a message as he is being blocked by $read$ which is waiting for an incoming message.

\subsubsection{Passing data to a thread}
To be able to pass all the data required to the two threads responsible for receiving and sending messages we decided to define a $clients$ $struct$ type which holds all the data needed by the features' respective functions. This allowed us to avoid using global variables.

\subsubsection{Timestamp}
For fetching the time to create the timestamp associated to a message, we decided to go with one of many options. At first we thought it would make more sense to fetch the receiver's local system time upon receiving a message, instead of sending the sender's local system time. \par
This is because it would avoid a situation where the sender and receiver don't have the same local time and thus the timestamps would be confusing. \par
However, we decided to fetch the sender's local time and send it as part of the message package.

\subsection{Server}

\subsubsection{Storing client sockets}
Due to $select$ being destructive to the file descriptor set that it is monitoring, we decided to create an array which holds all the sockets currently linked to the server. Once select detects a request for a connection / disconnection, the array is updated. This allowed us the reinitialise the modified set at the beginning of each iteration of the while loop.

\subsubsection{Signal handler}
When receiving a keyboard interrupt the server notifies through the stdout that it is closing all client. Next, it proceeds to close all client sockets and displays one by one which client socket it is closing before finally closing the server socket and exiting the program with success.

\subsection{Common.h}

We decided to use the common.h file given to us during the TPs 8 and 9. This allowed efficient error code checking when using socket related system calls.\par

We modified the $ssend$ and $receive$ functions so that they also take a pointer to $time$\_$t$ variable. 
\section{Limitations of the project}

\subsection{Messages limited to 1023 characters}
When testing the limitations of sending messages, we used a python script to flush the stdin of the client with 4000 characters by piping it's output. \par 
When doing this, the program holds, however, since our message buffer only accepts 1024 bits, when the $fgets$ function receives 1023 characters / bits it adds a $null$ $terminating$ $character$, saves it to the buffer and sends it as a message. \par
Interestingly enough, it continues to send the message in chunks of maximum 1023 characters. \par
This leads to the reception of a block of continuous text separated by timestamps and the sender's pseudonym prefixing each block. \par
We expect this is due to the functionality of the $fgets$ function.


\subsection{Receiving and sending messages simultaneously}
When typing the message you would like to send into the terminal, if you receive a message before having sent yours, your incomplete message will be muddled with the message you received from the server.

\section{Difficulties encountered}

\subsection{The time.h library}

The time.h library was totally new to us. We had to figure out how "raw"time, localtime and time formatting work, which was confusing at first. Our first implementation was to keep it simple. We create the time stamp the moment the client received a message and just print it with the received message. That way we wouldn't have to add a parameter to our sending and receiving system.
However, after thinking about it and rereading the assignment, we decided to add the "rawtime" to the system parameters and once the client receives a message, to format the raw time into a (hh:mm:ss) format.
That would firstly give as a more true time to the sending time and take us closer to the assignment requirements.

\subsection{Message structure}
We went back and forth on how to structure our message structure. As mentioned above, we first, simply timestamped our message at the receiving stage in the client. Which as we figured was not the right approach. So we changed it in such a manner to send the raw time alongside the message and formatting it at the receiving end to display it properly.
For the pseudonym we went a simple way though. Every time a client sends a message the his pseudo is added as prefix to the message and is thus treated as part of the message.

\newpage

\subsection{Using Select}
As we started this project, we quickly patched something based on the TP we had made. Our knowledge about Select wasn't great. This lead us to implement the server system in such a way to created a thread for every new client. Although it was functional, we went of tracks. Our assignment clearly stated to use select instead of multiple threads. So after acquiring the knowledge, we implemented Select to handle all the clients.  

\section{Original solutions}

\subsection{Displaying pseudo}
When the user runs the client script, he passes his pseudonym as an argument, which is then saved int a variable. To display the user's pseudo we added it as a prefix of every message they send, instead of sending it as part of the message package. 

\subsubsection{Advantage}
The advantage of proceeding this way is that it is simpler to manage. The server does not keep track of which client is who thus is only in charge of passing the already signed message along to the connected clients.
\subsubsection{Disadvantage}
The disadvantage of this solution is that since the server does not keep track of it's clients respective pseudonyms, when a user disconnects the server cannot communicate who disconnected to the remaining clients.

\section{Additional research}

\subsection{Port mapping}
To test our project even further we decided to port map our routers to each other and one of us launched a server. To our surprise, we were both able to connect to the server using our clients and send messages to each other.


\end{document}
